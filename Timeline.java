 /*********************************************************************************************************************************************************************
  *  This file is part of Timeline.
  *
  *  Timeline is free software: you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
  *  the Free Software Foundation, either version 3 of the License, or
  *  (at your option) any later version.
  *
  *  Timeline is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *  GNU General Public License for more details.
  *
  *  You should have received a copy of the GNU General Public License
  *  along with Timeline.  If not, see <http://www.gnu.org/licenses/>.
  **********************************************************************************************************************************************************************/
package Timeline;

import java.awt.Image;
import java.awt.image.BufferedImage;
import java.io.*;
import javax.imageio.ImageIO;
import javax.swing.ImageIcon;
import javax.swing.JFileChooser;
import javax.swing.filechooser.FileNameExtensionFilter;



public class Timeline extends javax.swing.JFrame 
{

    private String currentTitle;
    private String currentInfoBox;
 
    
    
    private int endYear;
    private int arrLength;
    private String timelineName;
    
    //head & tail for event list
    private Event head;
    private Event tail;
    
    //head & tail for tab GUI components
    private guiEvent guiHead;
    private guiEvent guiTail;
    
    private int currentYear;
    private String era;

    /**
     * Creates new form timelineGUI
     */
    public Timeline(){
        initComponents();
        
        //Make all new timeline components invisible to begin with
        namePrompt.setVisible(false);
        nameField.setVisible(false);
        endYearPrompt.setVisible(false);
        endYearField.setVisible(false);
        lengthPrompt.setVisible(false);
        lengthField.setVisible(false);
        submitButton.setVisible(false);
        yearChoiceNew.setVisible(false);
        errMsg.setVisible(false);
        
        Timeline.setVisible(false);
        Edit.setVisible(false);
        Search.setVisible(false);
        TitleLabel.setVisible(false);
        YearLabel.setVisible(false);
        editPhoto.setVisible(false);
        Edit.setVisible(false);
        Publish.setVisible(false);
        yearChoice.setVisible(false);
        tabBox.setVisible(false);
        addTab.setVisible(false);
        
        
}       
    

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">                          
    private void initComponents() {

        openButton = new javax.swing.JButton();
        titleText = new javax.swing.JLabel();
        nameField = new javax.swing.JTextField();
        endYearPrompt = new javax.swing.JLabel();
        lengthField = new javax.swing.JTextField();
        endYearField = new javax.swing.JTextField();
        newButton = new javax.swing.JButton();
        namePrompt = new javax.swing.JLabel();
        lengthPrompt = new javax.swing.JLabel();
        submitButton = new javax.swing.JButton();
        Search = new javax.swing.JTextField();
        Timeline = new javax.swing.JSlider();
        YearLabel = new javax.swing.JLabel();
        yearChoice = new javax.swing.JButton();
        yearChoiceNew = new javax.swing.JButton();
        errMsg = new javax.swing.JLabel();
        tabBox = new javax.swing.JTabbedPane();
        TitleLabel = new javax.swing.JLabel();
        Edit = new javax.swing.JButton();
        editPhoto = new javax.swing.JButton();
        Publish = new javax.swing.JButton();
        addTab = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        openButton.setText("Open");
        openButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                openButtonActionPerformed(evt);
            }
        });

        titleText.setText("Welcome to Timeline!  Would you like to open an existing timeline or create a new one?");

        nameField.setToolTipText("Hit Enter to submit");
        nameField.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                nameFieldActionPerformed(evt);
            }
        });

        endYearPrompt.setText("In what year would you like your timeline to end?");

        lengthField.setToolTipText("Hit Enter to submit");
        lengthField.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                lengthFieldActionPerformed(evt);
            }
        });

        endYearField.setToolTipText("Hit Enter to submit");
        endYearField.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                endYearFieldActionPerformed(evt);
            }
        });

        newButton.setText("New");
        newButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                newButtonActionPerformed(evt);
            }
        });

        namePrompt.setText("What would you like to call your timeline?");

        lengthPrompt.setText("How far back in time would you like to go?");

        submitButton.setText("Submit");
        submitButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                submitButtonActionPerformed(evt);
            }
        });

        Search.setToolTipText("Search for a specific year");
        Search.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                SearchActionPerformed(evt);
            }
        });

        Timeline.setMajorTickSpacing(100);
        Timeline.setMaximum(0);
        Timeline.setMinorTickSpacing(1);
        Timeline.setPaintTicks(true);
        Timeline.setSnapToTicks(true);
        Timeline.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                TimelineStateChanged(evt);
            }
        });

        YearLabel.setText("Year");

        yearChoice.setText("C.E.");
        yearChoice.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                yearChoiceActionPerformed(evt);
            }
        });

        yearChoiceNew.setText("C.E.");
        yearChoiceNew.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                yearChoiceNewActionPerformed(evt);
            }
        });

        errMsg.setFont(new java.awt.Font("Lucida Grande", 1, 13)); // NOI18N
        errMsg.setForeground(new java.awt.Color(255, 0, 0));
        errMsg.setText("* The timeline must be at least 1 year in length AND less than 1 million");

        TitleLabel.setText("Title");

        Edit.setText("Edit");
        Edit.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                EditActionPerformed(evt);
            }
        });

        editPhoto.setText("Edit Photo");
        editPhoto.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                editPhotoActionPerformed(evt);
            }
        });

        Publish.setText("Publish");
        Publish.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                PublishActionPerformed(evt);
            }
        });

        addTab.setText("[ + ]");
        addTab.setToolTipText("Add a new tab");
        addTab.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                addTabActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(YearLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 81, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(TitleLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 150, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(915, 915, 915))
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(openButton)
                                .addGap(18, 18, 18)
                                .addComponent(newButton))
                            .addGroup(layout.createSequentialGroup()
                                .addGap(25, 25, 25)
                                .addComponent(namePrompt)
                                .addGap(25, 25, 25)
                                .addComponent(nameField, javax.swing.GroupLayout.PREFERRED_SIZE, 130, javax.swing.GroupLayout.PREFERRED_SIZE))))
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(titleText))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(62, 62, 62)
                        .addComponent(endYearPrompt)
                        .addGap(25, 25, 25)
                        .addComponent(endYearField, javax.swing.GroupLayout.PREFERRED_SIZE, 130, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(yearChoiceNew))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(Search, javax.swing.GroupLayout.PREFERRED_SIZE, 99, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(yearChoice))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(159, 159, 159)
                        .addComponent(lengthPrompt)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(lengthField, javax.swing.GroupLayout.PREFERRED_SIZE, 130, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(errMsg)
                            .addComponent(submitButton)))
                    .addComponent(tabBox, javax.swing.GroupLayout.PREFERRED_SIZE, 1110, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(Timeline, javax.swing.GroupLayout.PREFERRED_SIZE, 1100, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(addTab, javax.swing.GroupLayout.PREFERRED_SIZE, 32, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(Edit)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(editPhoto, javax.swing.GroupLayout.PREFERRED_SIZE, 92, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(Publish, javax.swing.GroupLayout.PREFERRED_SIZE, 71, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(titleText)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(openButton)
                    .addComponent(newButton))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(namePrompt)
                    .addComponent(nameField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(endYearField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(endYearPrompt)
                    .addComponent(yearChoiceNew))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(lengthField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(submitButton)
                    .addComponent(lengthPrompt))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(errMsg, javax.swing.GroupLayout.PREFERRED_SIZE, 33, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(14, 14, 14)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(Search, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(yearChoice))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(YearLabel)
                    .addComponent(TitleLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 17, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(18, 18, 18)
                .addComponent(Timeline, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(Publish, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(Edit, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                        .addComponent(addTab, javax.swing.GroupLayout.PREFERRED_SIZE, 21, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addComponent(editPhoto)))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(tabBox, javax.swing.GroupLayout.PREFERRED_SIZE, 552, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>                        

    
    private void SearchActionPerformed(java.awt.event.ActionEvent evt) {                                       
                
        int input = Integer.parseInt(Search.getText());
        if(yearChoice.getText().equals("B.C.E."))
        {
            input = arrLength - endYear - input;
        }
        else
        {
            input = arrLength - (endYear-input);
        }
        if(!(input>arrLength && input<0)) //as long as the input does not exceed the length of the timeline and is not less than 0
        { 
            Timeline.setValue(input);
        }
    }                                      

    private void submitButtonActionPerformed(java.awt.event.ActionEvent evt) {                                             
        titleText.setVisible(false);
        namePrompt.setVisible(false);
        nameField.setVisible(false);
        endYearPrompt.setVisible(false);
        endYearField.setVisible(false);
        lengthPrompt.setVisible(false);
        lengthField.setVisible(false);
        submitButton.setVisible(false);
        yearChoiceNew.setVisible(false);
        openButton.setVisible(false);
        newButton.setVisible(false);
        errMsg.setVisible(false);
        

        buildNewTimeline();
        
    }                                            

    private void openButtonActionPerformed(java.awt.event.ActionEvent evt) {                                           
        titleText.setVisible(false);
        buildTimeline();
    }                                          

    private void newButtonActionPerformed(java.awt.event.ActionEvent evt) {                                          
        //Wait for the user to input data into the input boxes one step at a time, until all information is accurate and can be used to build the new timeline
        namePrompt.setVisible(true);
        nameField.setVisible(true);
    }                                         

    private void TimelineStateChanged(javax.swing.event.ChangeEvent evt) 
    {                                      
        int value=Timeline.getValue();
        int year;
        if(era.equals("C.E.")) //if the timeline includes both the C.E. era and B.C.E era
        {
            year = endYear - (arrLength-value);
            if(year >= 0) 
            {
                YearLabel.setText(year + " C.E.");
            }
            else
            {
                year = year * -1; //convert the negative number to a positive
                YearLabel.setText(year + " B.C.E.");
            }
        }
        else
        { //if the timeline only includes the B.C.E era
            year = (endYear + arrLength) - value;
            YearLabel.setText(year + " B.C.E.");
        }
        
        Event e = searchList(value);       
        if( e != null ) 
        {
            removeAllGuiEvents();
            buildTabs(e.getTitle(), e.getInfo(), e.getImage()); //build the first tab
            System.out.println("Setting existing event GUI");
            
            if(e.getNext() != null) //if the list has more than one item in it
            {
                System.out.println("There is more than one event in the list");
                int index = e.getIndex();
               //If this particular year contains one or more events start building addtional GUI tabs
                if(e.getNext().getIndex() == index) //if the next item in the list also has the same index
                {
                    e = e.getNext();//move to the next item in the list
                     //loop through the list building tabs as needed
                    do
                    {
                        System.out.println("Building already existing tab for " + e.getTitle());
                        buildTabs(e.getTitle(), e.getInfo(), e.getImage());
                        e = e.getNext();
                    }
                    while(e.getIndex() == index); //while the current item still has the same index
                }
                else
                {
                    System.out.println("There is only one tab for this event");
                }
            }
            
            /*if(e.getImage()==null)
            {
                searchGuiList(tabBox.getSelectedIndex()).getFrame().setIcon(null);
            }*/
        }
        else
        {
            System.out.println("Setting Empty GUI");
            setEmptyEventGUI();
        }
    }                                     

    private void endYearFieldActionPerformed(java.awt.event.ActionEvent evt) {                                             
        endYear = Integer.parseInt(endYearField.getText());
        System.out.println("year: " + endYear);
        lengthPrompt.setVisible(true);
        lengthField.setVisible(true);
    }                                            

    private void nameFieldActionPerformed(java.awt.event.ActionEvent evt) {                                          
        
        timelineName = nameField.getText();
        System.out.println("timeline name: " + timelineName);
        endYearPrompt.setVisible(true);
        endYearField.setVisible(true);
        yearChoiceNew.setVisible(true);
        
    }                                         

    private void lengthFieldActionPerformed(java.awt.event.ActionEvent evt) {                                            
        try
        {
            arrLength = Integer.parseInt(lengthField.getText());
        } 
        catch(NumberFormatException e)
        {
            errMsg.setVisible(true);
        }
        
        //As long as the Timeline specified will be less than a million years long AND bigger than 0 allow the user to create the timeline
        if( (arrLength > 0) && (arrLength <= 1000000) )
        {
            errMsg.setVisible(false);
            submitButton.setVisible(true);
        }
        else
        {
           errMsg.setVisible(true);
        }
        
    }                                           

    private void yearChoiceActionPerformed(java.awt.event.ActionEvent evt) {                                           
        if(yearChoice.getText().equals("C.E."))
            yearChoice.setText("B.C.E.");
        else
            yearChoice.setText("C.E.");
    }                                          

    private void yearChoiceNewActionPerformed(java.awt.event.ActionEvent evt) {                                              
        if(yearChoiceNew.getText().equals("C.E."))
            yearChoiceNew.setText("B.C.E.");
        else
            yearChoiceNew.setText("C.E.");  
    }                                             

    private void editPhotoActionPerformed(java.awt.event.ActionEvent evt) {                                          

        editPhoto();
    }                                         

    private void EditActionPerformed(java.awt.event.ActionEvent evt) {                                     
        
        //set the current titles to what is already saved in order to make decisions regarding what to update in the .txt file while editing
        
        guiEvent currentEvent = searchGuiList(tabBox.getSelectedIndex());
        currentTitle = searchGuiList(tabBox.getSelectedIndex()).getTitle().getText();
        currentInfoBox = searchGuiList(tabBox.getSelectedIndex()).getInfoBox().getText();

        
        enableAllTabs(false);
        Timeline.setEnabled(false); //disable the user from being able to use the slider until the editing has been published
        Search.setEditable(false);
        editPhoto.setVisible(false);
        addTab.setEnabled(false);
        Publish.setVisible(true); //make the publish button visible
        
        System.out.println("Currently selected tab is:" + tabBox.getSelectedIndex());
        /*For some reason these searches below produce null pointer exceptions.  The list has the items correctly indexed...
         it's a real puzzle */
        searchGuiList(tabBox.getSelectedIndex()).getTitle().setEditable(true); //set the textAreas to be editable
        searchGuiList(tabBox.getSelectedIndex()).getInfoBox().setEditable(true);
        
        
        System.out.println("editable? = " + searchGuiList(tabBox.getSelectedIndex()).getInfoBox().isEditable());
    }                                    

    private void PublishActionPerformed(java.awt.event.ActionEvent evt) {                                        

        //if any of the features are not null
        if( !(currentTitle.equals("") ) && !(currentInfoBox.equals("")) )
        {
            System.out.println("Editing an existing event...");

            if(!(currentTitle.equals(searchGuiList(tabBox.getSelectedIndex()).getTitle().getText())))
            { //if the Title has been changed
                editTitle();//edit the title
            }

            if(!(currentInfoBox.equals(searchGuiList(tabBox.getSelectedIndex()).getInfoBox().getText())))
            { //if the info has been changed
                editInfoBox(); //edit the info
            }
        }

        else //else if the fields are empty, indicating the user intends to make a new event
        {
            System.out.println("Creating new event...");
            File parentDir = new File ("Timelines");
            File timelineFile = new File(parentDir, timelineName+".txt"); //find the file to be written to
            try
            {
                FileWriter file = new FileWriter(timelineFile,true); //Make a new FileWriter with append = true so that new events will be appended instead of overwriting existing data
                PrintWriter shovel = new PrintWriter(file);
                shovel.println(Timeline.getValue());
                shovel.println(searchGuiList(tabBox.getSelectedIndex()).getTitle().getText());
                shovel.println(searchGuiList(tabBox.getSelectedIndex()).getInfoBox().getText());
                shovel.println("null");
                shovel.close();

                Event e = new Event(Timeline.getValue(),searchGuiList(tabBox.getSelectedIndex()).getTitle().getText(),searchGuiList(tabBox.getSelectedIndex()).getInfoBox().getText(),null);
                addToList(e);
            }
            catch(FileNotFoundException e)
            {
                // FileReader constructor might throw this exception
                System.err.println("Error: file \"" + timelineFile + "\" does not exist");
            }
            catch(IOException e)
            {
                // readLine() method might throw this exception
                System.err.println("Error: something bad happened reading" + timelineFile +", the file may be corrupt.  Editing the file independently of this program may cause problems" );
            }
        }

        Publish.setVisible(false); // hide the publish button
        searchGuiList(tabBox.getSelectedIndex()).getInfoBox().setEditable(false); //set the textAreas to be uneditable
        searchGuiList(tabBox.getSelectedIndex()).getTitle().setEditable(false);
        Timeline.setEnabled(true); // enable the JSlider
        Search.setEditable(true);
        tabBox.setTitleAt(tabBox.getSelectedIndex(), searchGuiList( tabBox.getSelectedIndex() ).getTitle().getText()  );
        enableAllTabs(true);
        editPhoto.setVisible(true);
        addTab.setEnabled(true);
        
        
    }                                       

    private void addTabActionPerformed(java.awt.event.ActionEvent evt) {                                       
        
        /* Build the tab GUI */
        /*********************************************************************************************************************************************************************/
        
        javax.swing.JPanel tabInterface1 = new javax.swing.JPanel();
        javax.swing.JLabel frame1 = new javax.swing.JLabel();
        javax.swing.JTextField title1 = new javax.swing.JTextField();
        javax.swing.JTextArea infoBox1 = new javax.swing.JTextArea();
        javax.swing.JScrollPane jScrollPane2 = new javax.swing.JScrollPane();
        
        
        title1.setEditable(false);
        title1.setBorder(javax.swing.BorderFactory.createMatteBorder(1, 1, 1, 1, new java.awt.Color(0, 51, 153)));

        infoBox1.setEditable(false);
        infoBox1.setColumns(20);
        infoBox1.setRows(5);
        infoBox1.setBorder(javax.swing.BorderFactory.createMatteBorder(1, 1, 1, 1, new java.awt.Color(0, 51, 153)));
        infoBox1.setLineWrap(true);
        infoBox1.setWrapStyleWord(true);
        
        jScrollPane2.setViewportView(infoBox1);
        
        javax.swing.GroupLayout tabInterfaceLayout = new javax.swing.GroupLayout(tabInterface1);
        tabInterface1.setLayout(tabInterfaceLayout);
        tabInterfaceLayout.setHorizontalGroup(
            tabInterfaceLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(tabInterfaceLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(tabInterfaceLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(tabInterfaceLayout.createSequentialGroup()
                        .addComponent(title1, javax.swing.GroupLayout.PREFERRED_SIZE, 291, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(0, 163, Short.MAX_VALUE))
                    .addComponent(frame1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addGap(18, 18, 18)
                .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 605, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );
        tabInterfaceLayout.setVerticalGroup(
            tabInterfaceLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(tabInterfaceLayout.createSequentialGroup()
                .addGap(14, 14, 14)
                .addComponent(title1, javax.swing.GroupLayout.PREFERRED_SIZE, 21, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(tabInterfaceLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(tabInterfaceLayout.createSequentialGroup()
                        .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 436, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                    .addGroup(tabInterfaceLayout.createSequentialGroup()
                        .addComponent(frame1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addGap(52, 52, 52))))
        );
        pack();
        /*********************************************************************************************************************************************************************/
       
        tabBox.addTab("", tabInterface1); //add a tab
        System.out.println("there are now " + tabBox.getTabCount() + " tabs");
        tabBox.setSelectedIndex(tabBox.getTabCount()-1); //set the currently selected tab to the newly added one
        guiEvent currentTab = new guiEvent(tabBox.getSelectedIndex(), frame1, title1, infoBox1); //make an instance of a tabbed gui Event
        System.out.println();
        addToGuiList(currentTab); //add the guiEvent to the list
    }                                      
/*********************************************************************************************************************************************************************/
/*********************************************************************************************************************************************************************/
    private void editPhoto()        
    {
        //Make a photo directory for the timeline if one has not already been created.  
        File photoDir = new File("Timelines/"+timelineName+".resources");
        currentYear = Timeline.getValue();
        if(!photoDir.exists()) //if there is no resources directory for this timeline
        { 
            System.out.println("create a new resources directory for: "+timelineName);
            photoDir.mkdir(); //actually make the directory
        }
        
        JFileChooser fileChooser = new JFileChooser();
        fileChooser.setDialogTitle("Choose an image");
        FileNameExtensionFilter filter = new FileNameExtensionFilter("jpg, gif and png images", "jpg", "gif", "png");
        fileChooser.setFileFilter(filter); //set the file filter to only search for png, jpg and gif images.
        this.getContentPane().add(fileChooser);
        fileChooser.setVisible(true);
        
        
        BufferedImage img=null;
        String imgName=null;
        try  //try to create the image    
        {
                int ret = fileChooser.showDialog(null, "Attach Image"); //creates a custom file chooser dialog with a custom "Attach Image" button
                
                if(ret == fileChooser.APPROVE_OPTION) //if the button has been clicked, get the selected file
                {
                    img = ImageIO.read(fileChooser.getSelectedFile()); //read the image
                    imgName = fileChooser.getName(fileChooser.getSelectedFile());
                    System.out.println(img);
                    //write the image to the resources folder
                    File writeImg = new File (photoDir+"/"+imgName);
                    ImageIO.write(img,"jpg",writeImg); //write the image to the photo directory 
                }
        }
        catch (IOException e) 
        {
            System.err.println(imgName + "is not a valid image");
        }

        if(img != null) //if the image is not null
            { // Make a JLabel that will contain an ImageIcon object.  The ImageIcon object takes a Buffered Image as parameters
               if(img.getWidth()>400 || img.getHeight()>400)
               { //if the image is large, divide it in half
                Image image = (img.getScaledInstance((img.getWidth()/2),(img.getHeight()/2),1)); //reduce the size of the image
                searchGuiList(tabBox.getSelectedIndex()).getFrame().setIcon(new ImageIcon(image));
               }
               else{
                searchGuiList(tabBox.getSelectedIndex()).getFrame().setIcon(new ImageIcon(img));
               }
            }
        
        File parentDir = new File ("Timelines");
        File timelineFile = new File(parentDir, timelineName+".txt"); //find the file to be written to
        String currentLine="love";
        try
        {
            //If the event does not yet exist
            System.out.println("current Year " + currentYear);
            if(searchList(currentYear) == null)
            {
                System.out.println("Creating new event...");
                FileWriter file = new FileWriter(timelineFile,true); //Make a new FileWriter with append = true so that new events will be appended instead of overwriting existing data
                PrintWriter shovel = new PrintWriter(file);
                shovel.println(Timeline.getValue());
                shovel.println("");
                shovel.println("");
                shovel.println(imgName);
                Event e = new Event(Timeline.getValue(),"","",img);
                addToList(e);
                shovel.close();
            }
            
            //Else if the event does already exist
            else
            {
                File tmp = File.createTempFile("tmp",".txt"); //make a temporary file
                BufferedReader br = new BufferedReader(new FileReader(timelineFile)); 
                BufferedWriter bw = new BufferedWriter(new FileWriter(tmp));
                
                bw.write(br.readLine()+"\n"); 
                //read the first line and write it to the temp file, in case by chance the year we want to edit is the length of the timeline

                while(!(currentLine.equals( Integer.toString( Timeline.getValue() ) ) ) )
                { //while the line does not have the current event's index
                    currentLine = br.readLine();
                    bw.write(currentLine+"\n"); //write the current line to the temp file
                }

                bw.write(br.readLine()+"\n"); //write the title
                bw.write(br.readLine()+"\n"); //write the info
                br.readLine(); //skip over the line with the photo

                bw.write(imgName + "\n"); //write the image name to the temp file

                searchList(currentYear).setImage(img);

                 while ((currentLine = br.readLine()) != null) //read everything after the where the photo was saved and write it to the temp file
                 {
                  bw.write(currentLine+"\n");
                 }

                 bw.close(); //close the files
                 br.close();

                File oldFile = timelineFile; //make a copy of the old file
                if (oldFile.delete()) //delete the file, if successful rename the tmp file and make it the usable file
                    tmp.renameTo(oldFile);
            }
        }
        catch(FileNotFoundException e)
        {
            // FileReader constructor might throw this exception
            System.err.println("Error: file \"" + timelineFile + "\" does not exist"); 
        }
        catch(IOException e)
        {
            // readLine() method might throw this exception
            System.err.println("Error: something bad happened reading" + timelineFile +", the file may be corrupt.  Editing the file independently of this program may cause problems" ); 
        }  
    }
    
    private void editTitle()
    {
        System.out.println("Editing title");     
        File parentDir = new File("Timelines");
        File timelineFile = new File(parentDir, timelineName + ".txt"); //find the file to be written to
        String currentLine="love";
        try
        {
            File tmp = File.createTempFile("tmp",".txt"); //make a temporary file
            BufferedReader br = new BufferedReader(new FileReader(timelineFile));  //make a reader for the current file
            BufferedWriter bw = new BufferedWriter(new FileWriter(tmp)); //make a writer for the tmp file
            
            
            bw.write(br.readLine()+"\n"); 
            //read the first line and write it to the temp file, in case by chance the year we want to edit is the length of the timeline
            
            
            while(!(currentLine.equals( Integer.toString( Timeline.getValue() ) ) ) )
            { //while the line does not have the current event's index
                currentLine = br.readLine();
                bw.write(currentLine+"\n"); //write the current line to the temp file
            }
            
            br.readLine(); //read the line containing the title (skipping it)
            bw.write(searchGuiList(tabBox.getSelectedIndex()).getTitle().getText()+"\n"); //write the edited text to the temp file
            
            searchList(currentYear).setTitle(searchGuiList(tabBox.getSelectedIndex()).getTitle().getText()); //update the list dynamically

             while ((currentLine = br.readLine()) != null) //read everthing after the title and write it to the temp file
             {
              bw.write(currentLine+"\n");
             }

             bw.close(); //close the files
             br.close();

            File oldFile = timelineFile; //make a copy of the old file
            if (oldFile.delete()) //delete the file, if successful rename the tmp file and make it the usable file
                tmp.renameTo(oldFile);
        }
        catch(FileNotFoundException e)
        {
            // FileReader constructor might throw this exception
            System.err.println("Error: file \"" + timelineFile + "\" does not exist"); 
        }
        catch(IOException e)
        {
            // readLine() method might throw this exception
            System.err.println("Error: something bad happened reading" + timelineFile +", the file may be corrupt.  Editing the file independently of this program may cause problems" ); 
        }  
    }
    
    private void editInfoBox()
    {
        System.out.println("Editing event information");
        File parentDir = new File ("Timelines");
        File timelineFile = new File(parentDir,timelineName +".txt"); //find the file to be written to
        String currentLine="love";
        try
        {
            File tmp = File.createTempFile("tmp",".txt"); //make a temporary file
            BufferedReader br = new BufferedReader(new FileReader(timelineFile)); 
            BufferedWriter bw = new BufferedWriter(new FileWriter(tmp));

            bw.write(br.readLine()+"\n"); 
            //read the first line and write it to the temp file, in case by chance the year we want to edit is the length of the timeline

            while(!(currentLine.equals( Integer.toString( Timeline.getValue() ) ) ) )
            { //while the line does not have the current event's index
                currentLine = br.readLine();
                bw.write(currentLine+"\n"); //write the current line to the temp file
            }

            bw.write(br.readLine()+"\n"); //read the line containing the title and print it
            br.readLine(); //read the line containing the old info (skipping it)
            bw.write(searchGuiList(tabBox.getSelectedIndex()).getInfoBox().getText()+"\n"); //write the edited text to the temp file
            
            searchList(currentYear).setInfo(searchGuiList(tabBox.getSelectedIndex()).getInfoBox().getText()); //update the list

             while ((currentLine = br.readLine()) != null) //read everthing after the info and write it to the temp file
             {
              bw.write(currentLine+"\n");
             }

             bw.close(); //close the files
             br.close();

            File oldFile = timelineFile; //make a copy of the old file
            if (oldFile.delete()) //delete the file, if successful rename the tmp file and make it the usable file
                tmp.renameTo(oldFile);
        }
        catch(FileNotFoundException e)
        {
            // FileReader constructor might throw this exception
            System.err.println("Error: file \"" + timelineFile + "\" does not exist"); 
        }
        catch(IOException e)
        {
            // readLine() method might throw this exception
            System.err.println("Error: something bad happened reading" + timelineFile +", the file may be corrupt.  Editing the file independently of this program may cause problems" ); 
        }   
    }
/*********************************************************************************************************************************************************************/
     
/*********************************************************************************************************************************************************************/    
    
    public void setEventGui(String title,String info, BufferedImage img)
    {
        removeAllGuiEvents();
        tabBox.setTitleAt(0,title);
        javax.swing.JLabel frame1 = new javax.swing.JLabel();
        javax.swing.JTextField title1 = new javax.swing.JTextField();
        javax.swing.JTextArea infoBox1 = new javax.swing.JTextArea();
        
        guiEvent currentTab = new guiEvent(tabBox.getSelectedIndex(), frame1, title1, infoBox1); //make an instance of a tabbed gui Event
        addToGuiList(currentTab);
        
        if(img != null) //if the image is not null
        {// Make a JLabel that will contain an ImageIcon object.  The ImageIcon object takes a Buffered Image as parameters
           if(img.getWidth()>400 || img.getHeight()>400)
           { //if the image is large, divide it in half
            Image image = (img.getScaledInstance((img.getWidth()/2),(img.getHeight()/2),1)); //reduce the size of the image
            searchGuiList(tabBox.getSelectedIndex()).getFrame().setIcon(new ImageIcon(image));
           }
           else{
            searchGuiList(tabBox.getSelectedIndex()).getFrame().setIcon(new ImageIcon(img));
           }
        }
        searchGuiList(tabBox.getSelectedIndex()).getInfoBox().setText(info); 
        searchGuiList(tabBox.getSelectedIndex()).getTitle().setText(title);
    }
    
    public void setEmptyEventGUI()
    {
        removeAllGuiEvents();
        /* Build the tab GUI */
        /*********************************************************************************************************************************************************************/
        javax.swing.JPanel tabInterface1 = new javax.swing.JPanel(); 
        javax.swing.JLabel frame1 = new javax.swing.JLabel();
        javax.swing.JTextField title1 = new javax.swing.JTextField();
        javax.swing.JTextArea infoBox1 = new javax.swing.JTextArea();
        javax.swing.JScrollPane jScrollPane2 = new javax.swing.JScrollPane();
        
        title1.setEditable(false);
        title1.setBorder(javax.swing.BorderFactory.createMatteBorder(1, 1, 1, 1, new java.awt.Color(0, 51, 153)));

        infoBox1.setEditable(false);
        infoBox1.setColumns(20);
        infoBox1.setRows(5);
        infoBox1.setBorder(javax.swing.BorderFactory.createMatteBorder(1, 1, 1, 1, new java.awt.Color(0, 51, 153)));
        infoBox1.setLineWrap(true);
        infoBox1.setWrapStyleWord(true);
        jScrollPane2.setViewportView(infoBox1);
        
        javax.swing.GroupLayout tabInterfaceLayout = new javax.swing.GroupLayout(tabInterface1);
        tabInterface1.setLayout(tabInterfaceLayout);
        tabInterfaceLayout.setHorizontalGroup(
            tabInterfaceLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(tabInterfaceLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(tabInterfaceLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(tabInterfaceLayout.createSequentialGroup()
                        .addComponent(title1, javax.swing.GroupLayout.PREFERRED_SIZE, 291, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(0, 163, Short.MAX_VALUE))
                    .addComponent(frame1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addGap(18, 18, 18)
                .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 605, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );
        tabInterfaceLayout.setVerticalGroup(
            tabInterfaceLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(tabInterfaceLayout.createSequentialGroup()
                .addGap(14, 14, 14)
                .addComponent(title1, javax.swing.GroupLayout.PREFERRED_SIZE, 21, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(tabInterfaceLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(tabInterfaceLayout.createSequentialGroup()
                        .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 436, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                    .addGroup(tabInterfaceLayout.createSequentialGroup()
                        .addComponent(frame1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addGap(52, 52, 52))))
        );
        pack();   
        tabBox.addTab("", tabInterface1); //add the tab
        guiEvent currentTab = new guiEvent(tabBox.getSelectedIndex(), frame1, title1, infoBox1); //make an instance of a tabbed gui Event
        addToGuiList(currentTab); //add the guiEvent to the list
        
        // Set the GUI components to be empty
        searchGuiList(tabBox.getSelectedIndex()).getTitle().setText("");
        searchGuiList(tabBox.getSelectedIndex()).getInfoBox().setText("");
        searchGuiList(tabBox.getSelectedIndex()).getFrame().setIcon(null);   
    }
/*********************************************************************************************************************************************************************/
      
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Timeline.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Timeline.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Timeline.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Timeline.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
        public void run() {
              new Timeline().setVisible(true); 
            }
        });
    }
/*********************************************************************************************************************************************************************/
    
/*********************************************************************************************************************************************************************/
    
    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
     *  Build an already existing timeline by reading information from the proper timeline file    *
     *  and creating a doubly linked list containing the information                               *
     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
    
    private void buildTimeline()
    {
        JFileChooser fileChooser = new JFileChooser();
        File currentDIR = new File("Timelines");
        fileChooser.setCurrentDirectory(currentDIR);
        fileChooser.setDialogTitle("Choose a timeline");
        FileNameExtensionFilter filter = new FileNameExtensionFilter("timeline files", "txt");
        fileChooser.setFileFilter(filter); //set the file filter to only search for png, jpg and gif images.
        this.getContentPane().add(fileChooser);
        fileChooser.setVisible(true);
        

        int ret = fileChooser.showDialog(null, "Open"); //creates a custom file chooser dialog with a custom "Open" button
        File timelineFile = null;
        
        if(ret == fileChooser.APPROVE_OPTION) //if the button has been clicked, get the selected file
        {
            String tempName = fileChooser.getName(fileChooser.getSelectedFile());
            timelineName = tempName.substring(0,( tempName.length()-4) ); //remove the .txt portion of the name
            System.out.println(timelineName);
            File parentDir = new File ("Timelines");
            timelineFile = new File(parentDir, timelineName+".txt");
        }
        
        try
        { 
            BufferedReader in = new BufferedReader( new FileReader(timelineFile) ); //make a BufferedReader class that reads from the desired Timeline file
            arrLength = Integer.parseInt(in.readLine());
            endYear = Integer.parseInt(in.readLine());
            era = in.readLine();

            
            //store information for the rest of the list
            while(in.ready())
            {
                int index = Integer.parseInt(in.readLine());//read the index
                String title = in.readLine();//read the title
                String info = in.readLine(); //read the info from the next line, we will have to modify this to make it access as many lines as needed
                String stringImg = in.readLine(); //read the name of the picture that goes with this event
                BufferedImage img = null;
                try 
                {
                    img = ImageIO.read(new File("Timelines/"+timelineName+".resources/"+stringImg)); //try to create a new image
                }
                catch (IOException e) {System.err.println("The image "+stringImg+" could not be found");}
                
                Event event = new Event(index,title,info,img);
                addToList(event);  
            }
        }
        catch(NullPointerException e)
        {
           System.err.println("No file was selected");
        }
        catch(FileNotFoundException e)
        {
            // FileReader constructor might throw this exception
            System.err.println("Error: file \"" + timelineFile + "\" does not exist"); 
      
        }
        catch(IOException e)
        {
            // readLine() method might throw this exception
            System.err.println("Error: something bad happened reading" + timelineFile +", the file may be corrupt.  Editing the file independently of this program may cause problems" ); 
        }
        newButton.setVisible(false);
        openButton.setVisible(false);
        buildSlider();
    }
    
    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
     *  Build a new timeline and put it in the Timelines directory (build this directory if it       *
     *  does not yet exist) and create a doubly linked list of the information in the timeline file  *
     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
    
    private void buildNewTimeline()
    {

        final File timelinesDir = new File("./Timelines"); //used to decide whether there is a Timelines directory 
        final File timelineFile;
        String filename;
        
        if(!timelinesDir.exists()) //if there is no current directory called Timelines, make one and put the new timeline in it
        { 
            File parentDir = new File("Timelines");
            parentDir.mkdir(); //actually make the directory
            filename = timelineName + ".txt";
            timelineFile = new File(parentDir, filename);
        }
        
        
        else //if the directory Timelines does exist then simply put a new timeline in it
        { 
       
            filename = timelineName + ".txt";
            
            timelineFile = new File("Timelines/"+filename); //make a new file in the Timelines directory
        }

        try
        {
            timelineFile.createNewFile(); // Creates a new file
        }
        catch(IOException e)
        {
            System.err.println("An I/O error occured, please try again");
        }

        try
        {
            File tmp = File.createTempFile("tmp",".txt"); //make a temporary file
            BufferedWriter bw = new BufferedWriter(new FileWriter(tmp));
            bw.write(Integer.toString(arrLength)+"\n");
            bw.write(Integer.toString(endYear)+"\n");
            bw.write(yearChoiceNew.getText()+"\n");
            
            bw.close();

            File oldFile = timelineFile; //make a copy of the old file
            if (oldFile.delete()) //delete the file, if successful rename the tmp file and make it the usable file
                tmp.renameTo(oldFile);

        
            BufferedReader in = new BufferedReader( new FileReader(timelineFile) ); //make a BufferedReader class that reads from the desired Timeline file
            arrLength = Integer.parseInt(in.readLine());
            endYear = Integer.parseInt(in.readLine());
            era = in.readLine();

            
            //store information in the list
            while(in.ready())
            {
                int index = Integer.parseInt(in.readLine());//read the index
                String title = in.readLine();//read the title
                String info = in.readLine(); //read the info from the next line, we will have to modify this to make it access as many lines as needed
                String stringImg = in.readLine(); //read the name of the picture that goes with this event
                BufferedImage img = null;
                try 
                {
                    img = ImageIO.read(new File("Timelines/"+timelineName+".resources/"+stringImg)); //try to create a new image
                }
                catch (IOException e) {System.err.println("The image "+stringImg+" could not be found");}
                
                Event e = new Event(index,title,info,img);
                addToList(e);  
            }
        }
        catch(FileNotFoundException e)
        {
            // FileReader constructor might throw this exception
            System.err.println("Error: file \"" + timelineFile + "\" does not exist"); 
        }
        catch(IOException e)
        {
            // readLine() method might throw this exception
            System.err.println("Error: something bad happened reading" + timelineFile +", the file may be corrupt.  Editing the file independently of this program may cause problems" ); 
        } 
        buildSlider();   
    }
    
    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
     *                                                                                              * 
     *                                                                                             *
     *                                                                                             * 
     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
    public void buildSlider()
    {
        
        Timeline.setVisible(true);
        Edit.setVisible(true);
        Search.setVisible(true);
        TitleLabel.setVisible(true);
        YearLabel.setVisible(true);
        editPhoto.setVisible(true);
        yearChoice.setVisible(true);
        tabBox.setVisible(true);
        addTab.setVisible(true);
        
        //build the JSlider GUI with one less than the array length accounting for index[0]
        Timeline.setMaximum(arrLength);
        TitleLabel.setText(timelineName);

        Publish.setVisible(false); //hide


        System.out.println("GUI timeline created");
    }
    
    private Event searchList(int index)
    {
        System.out.println("The user has chosen index: " + index);
        Event currentEvent = head;
        printList();
        
        if(currentEvent.getIndex() == index)
        {
            System.out.println("The desired event is the head.");
            return currentEvent;
        }
        else if(tail.getIndex() == index)
        {
            System.out.println("the desired event is the tail.");
            return tail;
        }    
        //Search through the list 
        currentEvent = currentEvent.getNext();
        do
        {
            if(currentEvent.getIndex() == index) 
            {
                System.out.println("We found the event we were looking for!");
                currentEvent.printAll();
                return currentEvent;
            }
            else 
            {
                currentEvent = currentEvent.getNext();
            }
        }while( !(currentEvent.equals(tail)) );
        
        //ELSE there is nothing in the list or the item requested was not found
        System.out.println("The event requested was not found");
        return null;
    }
    
    private void addToList(Event e)
    {
        Event currentEvent = head;
        System.out.println("Adding event " + e.getTitle() + " to the list");
        
        //if there is nothing in the list yet, make the head
        if(currentEvent == null) 
        {
            System.out.println("Adding the first event");
            head = tail = e;
        }
        else if(e.getIndex() < currentEvent.getIndex()) // Insert before head
        {
            e.setLast(tail);
            e.setNext(head);
            head = e;
        }
        else if(e.getIndex() >= tail.getIndex()) // Insert after tail
        {
            e.setNext(head);
            e.setLast(tail);
            e.getLast().setNext(e);
            tail = e;
        }
        else
        {
            // ELSE if we are inserting this event somewhere in the middle of the list
            while ( currentEvent.getIndex() <= e.getIndex() ) 
            {
                currentEvent = currentEvent.getNext();
            }
            System.out.println("The current event is: " + currentEvent.getTitle() );
            System.out.println("The next event in the list is: " + currentEvent.getNext().getTitle());
            System.out.println("the previous event in the list is: " + currentEvent.getLast().getTitle() );
            e.setNext(currentEvent);
            e.setLast(currentEvent.getLast());
            e.getLast().setNext(e);
            currentEvent.setLast(e);
        }
        printList();
        
    }
    private void printList()
    {
        System.out.print("Event List: ");
        Event currentEvent = head;
        if(currentEvent == tail)
        {
            System.out.print(currentEvent.getTitle());
        }
        else
        {
            while(currentEvent!=tail)
            {
                System.out.print(currentEvent.getTitle() + " -> ");
                currentEvent = currentEvent.getNext();
            }
            System.out.print(tail.getTitle());
        }
        System.out.println();
        System.out.println("The head is pointing to " + head.getTitle());
        System.out.println("The tail is pointing to " + tail.getTitle());
    }
    
    private void buildTabs(String title, String info, BufferedImage img)
    {
        
        /* Build the tab GUI */
        /*********************************************************************************************************************************************************************/
        
        javax.swing.JPanel tabInterface1 = new javax.swing.JPanel(); 
        javax.swing.JLabel frame1 = new javax.swing.JLabel();
        javax.swing.JTextField title1 = new javax.swing.JTextField();
        javax.swing.JTextArea infoBox1 = new javax.swing.JTextArea();
        javax.swing.JScrollPane jScrollPane2 = new javax.swing.JScrollPane();
        
        title1.setEditable(false);
        title1.setBorder(javax.swing.BorderFactory.createMatteBorder(1, 1, 1, 1, new java.awt.Color(0, 51, 153)));

        infoBox1.setEditable(false);
        infoBox1.setColumns(20);
        infoBox1.setRows(5);
        infoBox1.setBorder(javax.swing.BorderFactory.createMatteBorder(1, 1, 1, 1, new java.awt.Color(0, 51, 153)));
        infoBox1.setLineWrap(true);
        infoBox1.setWrapStyleWord(true);
        jScrollPane2.setViewportView(infoBox1);
        
        javax.swing.GroupLayout tabInterfaceLayout = new javax.swing.GroupLayout(tabInterface1);
        tabInterface1.setLayout(tabInterfaceLayout);
        tabInterfaceLayout.setHorizontalGroup(
            tabInterfaceLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(tabInterfaceLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(tabInterfaceLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(tabInterfaceLayout.createSequentialGroup()
                        .addComponent(title1, javax.swing.GroupLayout.PREFERRED_SIZE, 291, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(0, 163, Short.MAX_VALUE))
                    .addComponent(frame1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addGap(18, 18, 18)
                .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 605, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );
        tabInterfaceLayout.setVerticalGroup(
            tabInterfaceLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(tabInterfaceLayout.createSequentialGroup()
                .addGap(14, 14, 14)
                .addComponent(title1, javax.swing.GroupLayout.PREFERRED_SIZE, 21, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(tabInterfaceLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(tabInterfaceLayout.createSequentialGroup()
                        .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 436, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                    .addGroup(tabInterfaceLayout.createSequentialGroup()
                        .addComponent(frame1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addGap(52, 52, 52))))
        );
        pack();
        
        tabBox.addTab(title, tabInterface1); //add the tab
        title1.setText(title); //dynamically fill each tab with the required information
        infoBox1.setText(info);
        if(img != null) //if the image is not null
        {// Make a JLabel that will contain an ImageIcon object.  The ImageIcon object takes a Buffered Image as parameters
           if(img.getWidth()>400 || img.getHeight()>400)
           { //if the image is large, divide it in half
            Image image = (img.getScaledInstance((img.getWidth()/2),(img.getHeight()/2),1)); //reduce the size of the image
            frame1.setIcon(new ImageIcon(image));
           }
           else{
            frame1.setIcon(new ImageIcon(img));
           }
        }
        System.out.println("Added Tab " + tabBox.getTitleAt((tabBox.getTabCount()-1)) + " at index " + (tabBox.getTabCount()-1) + " to the GUI." );
        guiEvent currentTab = new guiEvent(tabBox.getTabCount()-1, frame1, title1, infoBox1); //make an instance of a tabbed gui Event
        addToGuiList(currentTab); //add the guiEvent to the list
        
        
    }
    
    private void addToGuiList(guiEvent e)
    {
        guiEvent currentEvent = guiHead;
        System.out.println("Adding tab at index" + " [" + e.getIndex() + "] to the list");
        System.out.println("Title: " + e.getTitle().getText());
        System.out.println("Info: " + e.getInfoBox().getText());
        System.out.println("Frame: " + e.getFrame());
        //if there is nothing in the list yet, make the head
        if(currentEvent == null) 
        {
            System.out.println("Adding the first guiEvent");
            guiHead = guiTail = e;
            printGuiList();
        }
        else if(e.getIndex() < currentEvent.getIndex()) // Insert before head
        {
            System.out.println("Inserting new guiEvent before the head");
            e.setLast(guiTail);
            e.setNext(guiHead);
            guiHead = e;
            printGuiList();
        }
        else if(e.getIndex() > guiTail.getIndex()) // Insert after tail
        {
            System.out.println("Inserting new guiEvent after the tail");
            e.setNext(guiHead);
            e.setLast(guiTail);
            e.getLast().setNext(e);
            guiHead.setLast(e);
            guiTail = e;
            printGuiList();
        }
        else
        {
            System.out.println("WHY ARE YOU HERE????");
            // ELSE if we are inserting this event somewhere in the middle of the list
            System.out.println("Inserting new guiEvent somewhere in the middle of the list");
            while ( currentEvent.getIndex() < e.getIndex() ) 
            {
                currentEvent = currentEvent.getNext();
            }
            e.setNext(currentEvent);
            e.setLast(currentEvent.getLast());
            e.getLast().setNext(e);
            currentEvent.setLast(e);
            printGuiList();
        }    
    }
    private guiEvent searchGuiList(int index)
    {
        System.out.println("The user has chosen index: " + index);
        guiEvent currentEvent = guiHead;

        //If the list only has one item in it AND it is the one we are indexing
        if( currentEvent.equals(guiTail) && index == currentEvent.getIndex() )
        {
            System.out.println("The list has only one item in it");
            return currentEvent;
        }
        
        //Search through the list
        if( !(guiHead.equals(guiTail)) ) //check to see if there is at least more than 1 event
            do 
            {
                if(currentEvent.getIndex() == index) 
                {
                    System.out.println("checking index " + currentEvent.getIndex() );
                    return currentEvent;
                }
                else 
                {
                    System.out.println( "Moving on to index: " + currentEvent.getNext().getIndex() );
                    currentEvent = currentEvent.getNext();
                }
            }  while( !( currentEvent.equals(guiHead) ) );
        else
        {
            return currentEvent; //if there is only 1 item in the list return that one
        }
        
        //ELSE there is nothing in the list or the item requested was not found
        System.out.println("The event requested was not found");
        return null;
    }
    private void removeAllGuiEvents()
    {
        
        
        //Remove all excess tabs from the GUI
        System.out.println("Removing all excess tabs");
        if(guiHead != null)
        {
            if(tabBox.getTabCount() == 1) //if there is only one tab
            {
                System.out.println("Removing the one tab");
                tabBox.removeTabAt(0); //remove it
            }
        
            else 
            { //else if there are several tabs to remove
                System.out.println("Removing tabs");
                /*System.out.println("There are currently: " + tabBox.getTabCount() + " tabs");
                System.out.println("1. " + tabBox.getTitleAt(0));
                System.out.println("2. " + tabBox.getTitleAt(1));
                System.out.println("3. " + tabBox.getTitleAt(2));
                */
                tabBox.removeAll();
            }
            
            
            System.out.println("There are now: " + tabBox.getTabCount() + " tabs");
          
            guiHead.setNext(null);
            guiHead.setLast(null);
            guiTail.setNext(null);
            guiTail.setLast(null);
            guiHead = guiTail = null;
        }    
    }
    private void enableAllTabs(boolean onOroff)
    {
        //disable all other tabs, other than the one we are currently editing
        printGuiList();
        for(int i = 0; i < tabBox.getTabCount(); i++)
        { //loop through the tab gui list, if the tab is not the one we are editing disable it
            
            
            if( i != tabBox.getSelectedIndex() )
            {
                System.out.println("Disabled tab at index:" + i);
                tabBox.setEnabledAt(i, onOroff);
            }
                
        }
    }
    private void printGuiList()
    {
        guiEvent currentEvent = guiHead;
        if(currentEvent == guiTail)
        {
            System.out.println(currentEvent.getTitle().getText() + "[" + currentEvent.getIndex() + "]");
        }
        else
        {
            while(currentEvent!=guiTail)
            {
                System.out.print(currentEvent.getTitle().getText() + "[" + currentEvent.getIndex() + "]" + " -> ");
                currentEvent = currentEvent.getNext();
            }
            System.out.print(currentEvent.getTitle().getText() + "[" + currentEvent.getIndex() + "]");
            System.out.println();
        }
        System.out.println("The tabHead is pointing to " + guiHead.getTitle().getText());
        System.out.println("The tabTail is pointing to " + guiTail.getTitle().getText());
    }
/*********************************************************************************************************************************************************************/

    // Variables declaration - do not modify                     
    private javax.swing.JButton Edit;
    private javax.swing.JButton Publish;
    private javax.swing.JTextField Search;
    private javax.swing.JSlider Timeline;
    private javax.swing.JLabel TitleLabel;
    private javax.swing.JLabel YearLabel;
    private javax.swing.JButton addTab;
    private javax.swing.JButton editPhoto;
    private javax.swing.JTextField endYearField;
    private javax.swing.JLabel endYearPrompt;
    private javax.swing.JLabel errMsg;
    private javax.swing.JTextField lengthField;
    private javax.swing.JLabel lengthPrompt;
    private javax.swing.JTextField nameField;
    private javax.swing.JLabel namePrompt;
    private javax.swing.JButton newButton;
    private javax.swing.JButton openButton;
    private javax.swing.JButton submitButton;
    private javax.swing.JTabbedPane tabBox;
    private javax.swing.JLabel titleText;
    private javax.swing.JButton yearChoice;
    private javax.swing.JButton yearChoiceNew;
    // End of variables declaration                   
}
